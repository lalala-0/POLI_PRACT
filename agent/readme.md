# TODO

- написать конфиг и его парсер (порт агента, интервал сбора метрик, ?id хоста?)
- исправить ошибки в сборщике инфы докера и сетевых портов

# Как сие работает? Работа агента мониторинга с двумя горутинами

Агент мониторинга построен на взаимодействии двух горутин, которые разделяют между собой конфигурацию и метрики:

## Горутина 1: HTTP-сервер (транспортный слой)

**Что делает:**
- Принимает HTTP-запросы от пользователей
- Предоставляет доступ к собранным метрикам через API
- Изменяет конфигурацию по запросу пользователя
- Хранит последние полученные метрики в переменной `lastMetrics`

**API эндпоинты:**
- `GET /metrics/*` - получение метрик
- `POST /config/*` - изменение конфигурации

## Горутина 2: Сборщик метрик (коллекторы)

**Что делает:**
- Периодически (с интервалом из конфигурации) собирает метрики системы
- Использует различные коллекторы для сбора разных типов метрик
- Отправляет собранные метрики в канал для HTTP-сервера
- Обновляет настройки коллекторов на основе текущей конфигурации

## Механизм взаимодействия

1. **Обмен метриками:**
   ```
   Горутина 2 (сборщик) ---> Канал metricsCh ---> Горутина 1 (HTTP-сервер)
   ```

2. **Обмен конфигурацией:**
   ```
   Клиент ---> HTTP API ---> MetricsService ---> Коллекторы
   ```

3. **Синхронизация данных:**
    - `metricsService` использует `sync.RWMutex` для безопасного доступа
    - Метрики передаются через буферизованный канал (`metricsCh`)

## Пример потока данных

1. Клиент отправляет запрос на обновление списка процессов:
   ```
   POST /config/processes --> updateProcessConfig() --> metricsService.UpdateProcessConfig()
   ```

2. Горутина сборщика при следующей итерации:
   ```
   Проверяет изменения в конфигурации --> Обновляет коллекторы --> Собирает метрики
   ```

3. Собранные метрики передаются в HTTP-сервер:
   ```
   Сборщик --> metricsCh --> HTTP-сервер.lastMetrics
   ```

4. Клиент запрашивает метрики:
   ```
   GET /metrics --> HTTP-сервер возвращает lastMetrics
   ```

Такая архитектура обеспечивает разделение ответственности и эффективный обмен данными между компонентами системы.

# Вопросики

- Порт, на котором запускается агент, задается в конфиге или в командной строке?
- Агент должен собирать метрики только при получении get запроса от ЦМ ИЛИ собирать метрики с некоторым интервалом и отправлять при запросе ЦМ, то что он уже насобирал? (пока делается второе)
- Апи нормальное?
- Метрики нормальные? Надо чем-то дополнить?


# Про скрипт 

Установка и использование
Сохраните скрипт как monitoring-agent.sh и сделайте его исполняемым:

`chmod +x monitoring-agent.sh`

Установите зависимости (на Debian/Ubuntu):


`sudo apt update && sudo apt install jq bc netcat procps`

Запустите агент:

`sudo ./monitoring-agent.sh`

Проверка

`curl http://localhost:8080/`


# Как добавить в автозапуск через systemctl
1. Компилируем бинарник.
- переходим в папку с проектом
- создаем экзешник: `go build ./cmd/main.go`

2. Распределяем необходимые файлы по директориям
- Создаем директорию `sudo mkdir -p /etc/agent`
- Конфиг config.yaml добавляем в папку /etc/agent `sudo cp ./config/agent.yaml /etc/agent/`
- Создаем директорию `sudo mkdir -p /bin/agent`
- Бинарник main.exe добавляем в папку /bin/agent `sudo cp ./main.exe /bin/agent/`

3. Создаём agent.service
- копируем юнит-файл `sudo cp ./deployments/agent.service /etc/systemd/system/`

4. Перезапускаем systemd
```bash
sudo systemctl daemon-reload
sudo systemctl enable agent.service
sudo systemctl start agent.service
```

5. Проверка
```bash
sudo systemctl status agent.service
journalctl -u agent.service -f
```



